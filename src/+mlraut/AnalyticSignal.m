classdef AnalyticSignal < handle & mlraut.HCP
    %% Implements Raut, et al.  Global waves synchronize the brain's functional systems with fluctuating arousal.
    %  https://www.science.org/doi/10.1126/sciadv.abf2709
    %  Extends physio_phase_mapping.m.
    %  Emphasizes consistency of analytic signal generated by Hilbert transform.
    %  
    %  Created 29-Nov-2022 13:47:07 by jjlee in repository /Users/jjlee/MATLAB-Drive/mlraut/src/+mlraut.
    %  Developed on Matlab 9.13.0.2105380 (R2022b) Update 2 for MACI64.  Copyright 2022 John J. Lee.
    

    properties
        do_global_signal_regression  % logical
        do_plot_emd
        do_plot_global_physio
        do_plot_networks
        do_plot_radar
        do_plot_wavelets
        do_save
        do_save_bias_to_rsns  % see also meta_save()
        do_save_ciftis_mad  % see also meta_save()
        do_save_ciftis
        do_save_ciftis_of_diffs
        do_save_dynamic
        do_save_subset

        filter_order  % >= 2
        force_band  % force bandpass to [0.01 0.1] Hz
        force_legacy_butter  
        frac_ext_physio  % fraction of external physio power
        norm  % see also this.rescaling for kind of norm
        source_physio  % isscalartext
        source_physio_supplementary  % string
        v_physio  % velocity of putative physio signal, m/s
    end

    properties (Dependent)
        anatomy_list  % {'ctx', 'str', 'thal', 'cbm'}
        digital_filter
        global_signal
        hp_thresh  % low freq. bound, Ryan ~ 0.01 Hz
        json
        lp_thresh  % high freq. bound, Ryan ~ 0.05-0.1 Hz, for CSF studies ~ 0.1 Hz
        plot_range
        rescaling
        rsn_list
        tags_user  % for filenames

        bold_signal
        physio_angle
        physio_signal
        physio_supplementary
        plotting
        roi
        v_physio_is_inf  % v_physio reaches head diameter in time << tr
    end

    methods %% GET, SET
        function g = get.anatomy_list(this)
            g = this.anatomy_list_;
        end
        
        function g = get.digital_filter(this)
            g = this.digital_filter_;

        end
        
        function g = get.global_signal(this)
            %% global_signal <- double greyordinates <- mean(this.task_niigz, "greyords")

            if ~isempty(this.global_signal_)
                g = this.global_signal_;
                return
            end

            % task niigz in 4D
            niigz = this.task_niigz();
            sz = size(niigz);
            assert(sz(4) == this.num_frames)
            niigz = reshape(niigz, [sz(1)*sz(2)*sz(3), sz(4)])';
            niigz = double(niigz);  % Nt x Ngo double

            % task mask in 3D ~ task signal reference
            msk = this.task_mask_niigz();
            msk = reshape(msk, [sz(1)*sz(2)*sz(3), 1])';
            msk = logical(msk);  % 1 x Ngo logical

            g = niigz(:, msk);
            g = mean(g, 2);  % mean over greyords
            this.global_signal_ = g;
        end

        function g = get.hp_thresh(this)
            N = this.num_frames - this.num_frames_to_trim;
            Nyquist = (this.Fs/2)*(1/N); % Nyquist limited Hz
            if this.force_band
                g = Nyquist;
                return
            end
            if ~isempty(this.hp_thresh_)
                g = max(this.hp_thresh_, Nyquist);
                return
            end
            g = this.hp_thresh_; 
        end

        function g = get.json(this)
            g = this.cohort_data_.json;
        end
        
        function     set.json(this, s)
            this.cohort_data_.json = s;
        end

        function g = get.lp_thresh(this)
            Nyquist = this.Fs/2 - 1e-6; % Nyquist limited Hz
            if this.force_band
                g = Nyquist;
                return
            end
            if ~isempty(this.lp_thresh_)
                g = min(this.lp_thresh_, Nyquist);
                return
            end
            g = this.lp_thresh_;
        end     

        function g = get.plot_range(this)
            g = this.plotting_.plot_range;
        end  

        function g = get.rescaling(this)
            g = this.rescaling_;
        end

        function g = get.rsn_list(~)
            g = mlraut.NetworkData.NETWORKS_YEO_NAMES;
        end

        function g = get.tags_user(this)
            g = this.tags_user_;
        end        
        
        function     set.tags_user(this, s)
            this.tags_user_ = s;
        end

        function g = get.bold_signal(this)
            g = this.bold_signal_;
        end

        function g = get.physio_angle(this)
            if isempty(this.physio_signal)
                g = [];
                return
            end
            if isempty(this.physio_angle_)
               this.physio_angle_ = angle(mean(this.physio_signal, 2));
            end
            g = this.physio_angle_;
        end

        function g = get.physio_signal(this)
            g = this.physio_signal_;
        end

        function g = get.physio_supplementary(this)
            g = this.physio_supplementary_;
        end

        function g = get.plotting(this)
            g = this.plotting_;
        end

        function g = get.roi(this)
            g = this.roi_;
        end

        function g = get.v_physio_is_inf(this)
            g = this.v_physio > 10/this.tr;  % m/s
        end
    end
    
    methods

        %% helpers for buillding

        function psi = angle(this, varargin)
            psi = this.twistors_.angle(varargin{:});
        end

        function psi = average_anat_signal(this, psi, opts)
            arguments
                this mlraut.AnalyticSignal
                psi {mustBeNumeric}
                opts.network_type {mustBeText} = "cortical"
            end

            if startsWith(opts.network_type, "cerebell", IgnoreCase=true) || strcmp(opts.network_type, "crb")
                dat = mlraut.CerebellarData(this, psi);
                psi = dat.build_anat_signal();
                return
            end
            if startsWith(opts.network_type, "cort", IgnoreCase=true) || strcmp(opts.network_type, "ctx")
                dat = mlraut.CorticalData(this, psi);
                psi = dat.build_anat_signal();
                return
            end
            if startsWith(opts.network_type, "str", IgnoreCase=true)
                dat = mlraut.StriatalData(this, psi);
                psi = dat.build_anat_signal();
                return
            end
            if startsWith(opts.network_type, "thal", IgnoreCase=true)
                dat = mlraut.ThalamicData(this, psi);
                psi = dat.build_anat_signal();
                return
            end
            error("mlraut:ValueError", stackstr())
        end

        function psi = average_network_signal(this, psi, opts)
            arguments
                this mlraut.AnalyticSignal
                psi {mustBeNumeric}
                opts.network_type {mustBeText} = "cortical"
            end

            if isvector(psi)
                return
            end

            if startsWith(opts.network_type, "cerebell", IgnoreCase=true) || strcmp(opts.network_type, "crb")
                dat = mlraut.CerebellarData(this, psi);
                psi = dat.build_Yeo_signals();
                return
            end
            if startsWith(opts.network_type, "cort", IgnoreCase=true) || strcmp(opts.network_type, "ctx")
                dat = mlraut.CorticalData(this, psi);
                psi = dat.build_Yeo_signals();
                return
            end
            if startsWith(opts.network_type, "str", IgnoreCase=true)
                dat = mlraut.StriatalData(this, psi);
                psi = dat.build_Yeo_signals();
                return
            end
            if startsWith(opts.network_type, "thal", IgnoreCase=true)
                dat = mlraut.ThalamicData(this, psi);
                psi = dat.build_Yeo_signals();
                return
            end
            error("mlraut:ValueError", stackstr())
        end

        function dat1 = build_band_passed(this, dat, opts)
            %% Implements designfilt, caching results
            %  web(fullfile(docroot, 'signal/ug/practical-introduction-to-digital-filtering.html?browser=F1help'))
            %  
            %  Args:
            %      this mlraut.AnalyticSignal
            %      dat double
            %      opts.do_reset logical = false            

            arguments
                this mlraut.AnalyticSignal
                dat double
                opts.do_reset logical = false
            end

            if isempty(this.lp_thresh) && isempty(this.hp_thresh)
                dat1 = dat;
                return
            end

            if this.force_legacy_butter
                dat1 = this.build_band_passed_butter(dat);
                return
            end

            try
                if isempty(this.digital_filter_) || opts.do_reset

                    % default design is 'butter'

                    if isempty(this.lp_thresh) && ~isempty(this.hp_thresh)
                        this.digital_filter_ = designfilt("highpassiir", ...
                            FilterOrder=this.filter_order, ...
                            HalfPowerFrequency=this.hp_thresh, ...
                            SampleRate=this.Fs);
                    elseif ~isempty(this.lp_thresh) && isempty(this.hp_thresh)
                        this.digital_filter_ = designfilt("lowpassiir", ...
                            FilterOrder=this.filter_order, ...
                            HalfPowerFrequency=this.lp_thresh, ...
                            SampleRate=this.Fs);
                    else
                        this.digital_filter_ = designfilt("bandpassiir", ...
                            FilterOrder=this.filter_order, ...
                            HalfPowerFrequency1=this.hp_thresh, HalfPowerFrequency2=this.lp_thresh, ...
                            SampleRate=this.Fs);
                    end
                end

                % zero-phase digital filtering; https://www.mathworks.com/help/releases/R2024b/signal/ref/filtfilt.html
                dat1 = filtfilt(this.digital_filter_, double(dat));
                if isa(dat, 'single')
                    dat1 = single(dat1);
                end
                if isa(dat, 'double')
                    dat1 = double(dat1);
                end
            catch ME
                warning(ME.message, "resorting to legacy butterworth")
                dat1 = this.build_band_passed_butter(dat);
            end
        end
        
        function dat1 = build_band_passed_butter(this, dat)
            %% Implements butter:  web(fullfile(docroot, 'signal/ref/butter.html?browser=F1help#bucsfmj')) 
            %  with configuration matched to Ryan's.  
            %  See also web(fullfile(docroot, 'signal/ug/practical-introduction-to-digital-filtering.html')) .
            %  Returns:
            %      dat1 same num. type as dat
            %      dat1 ~ ones() if dat ~ zeros() to accomodate no no physio
            %      sos, for visualization with `freqz(sos,[],this.Fs)`

            if all(dat == 0)
                dat1 = ones(size(dat));
                return
            end
            if isempty(this.lp_thresh) && isempty(this.hp_thresh)
                dat1 = dat;
                return
            end
            [z,p,k] = butter(this.filter_order, [this.hp_thresh, this.lp_thresh - eps('single')]/(this.Fs/2)); % digital Wn in [0, 1]
            [sos,g] = zp2sos(z, p, k);
            this.digital_filter_ = sos;
            dat1 = filtfilt(sos, g, double(dat));
            if isa(dat, 'single')
                dat1 = single(dat1);
            end
            if isa(dat, 'double')
                dat1 = double(dat1);
            end
        end

        function psi = build_centered(this, psi, opts)
            arguments
                this mlraut.AnalyticSignal %#ok<INUSA>
                psi {mustBeNumeric,mustBeNonempty}
                opts.reference {mustBeNumeric} = psi                
            end

            if all(psi == 0)
                return
            end

            psi = psi - mean(opts.reference, 'all', 'omitnan');
        end

        function psi = build_centered_and_rescaled(this, psi, varargin)
            %% Mimics z-score of |psi(t,x)> using mean and mad.

            psi = this.build_centered(psi, varargin{:});
            psi = this.build_rescaled(psi, varargin{:});
        end

        function psi = build_global_signal_regressed(this, psi)
            arguments
                this mlraut.AnalyticSignal
                psi {mustBeNumeric,mustBeNonempty}
            end

            if ~this.do_global_signal_regression
                return
            end
            if all(psi == 0)
                return
            end

            psi = psi - this.global_signal;
        end

        function n = build_norm(this, psi, opts)
            arguments
                this mlraut.AnalyticSignal
                psi {mustBeNumeric}
                opts.dim = "all" 
            end
            % n = mad(abs(psi), 0, opts.dim);  % mean abs. dev., doesn't scale psi and phi comparably
            % n = mad(abs(psi), 1, opts.dim);  % median abs. dev., doesn't scale psi and phi comparably
            % n = norm(psi);  % 2-norm seems more consistent with 2-spinors, but discrepancy of psi, phi ~ 1e6
            % n = max(psi, [], opts.dim);  % discrepancy of psi, phi ~ 1e3

            switch convertStringsToChars(this.rescaling)
                case {'none'}
                    n = 1;
                otherwise
                    n = iqr(psi, opts.dim);  % discrepancy of psi, phi ~ 3
            end
            this.norm = n;
        end

        function psi = build_rescaled(this, psi, opts)
            arguments
                this mlraut.AnalyticSignal 
                psi {mustBeNumeric,mustBeNonempty}
                opts.reference {mustBeNumeric} = psi
            end

            if all(psi == 0)
                return
            end
            
            d = this.build_norm(opts.reference);
            psi = psi./d;
        end

        function concat_frames(this, that)
            arguments
                this mlraut.AnalyticSignal
                that mlraut.AnalyticSignal
            end

            this.global_signal_ = [this.global_signal_; that.global_signal_];
            this.bold_signal_ = [this.bold_signal_; that.bold_signal_];
            this.physio_signal_ = [this.physio_signal_; that.physio_signal_];
        end

        function this = malloc(this)
            %% reset for new tasks or new subjects

            this = malloc@mlraut.HCP(this);   

            % accumulate for statistics on serialized AnalyticSignalHCP
            this.bold_signal_ = complex(nan(this.num_frames, this.num_nodes));  % largest
            this.physio_signal_ = complex(nan(this.num_frames, this.num_nodes));  % largest
            this.digital_filter_ = [];

            % utilities
            plot_range_ = 1:round(200/this.tr);
            this.plotting_ = mlraut.Plotting.create(this, plot_range=plot_range_);
        end 

        function fqfn = mat_fqfn(this, opts)
            %% see also tags()

            arguments
                this mlraut.AnalyticSignal
                opts.more_tags {mustBeTextScalar} = ""
            end

            t = this.tags(opts.more_tags);

            sub = strrep(this.current_subject, "sub-", "");
            sub = strrep(sub, filesep, "");
            ses = strrep(this.current_task, "ses-", "");
            ses = strrep(ses, "_", "-");

            assert(isfolder(this.out_dir), stackstr())
            fqfn = fullfile(this.out_dir, ...
                sprintf("sub-%s_ses-%s_%s.mat", sub, ses, t));
            % disp(stackstr() + ": mat_fqfn=" + fqfn)
        end

        function p = mix_physio(this, p_0, p_1)
            %% mix phyio signals:  p := (1 - f)*p_0 + f*p_1, f ~ this.frac_ext_physio, weighted by norms

            f = this.frac_ext_physio;
            if f < eps
                p = p_0;
                return
            end
            if f > 1 - eps
                p = p_1;
                return
            end

            n_0 = this.build_norm(p_0);  % scalars
            n_1 = this.build_norm(p_1);

            g_0 = 1/n_1 + 2*(1 - 1/n_1)*f;  % scalars
            g_1 = 2 - 1/n_0 - 2*(1 - 1/n_0)*f;

            p = (1 - f)*g_0*n_1*p_0 + f*g_1*n_0*p_1;  % mat -> mat
        end

        function psi = T(this, varargin)
            psi = this.twistors_.T(varargin{:});
        end

        function psi = unwrap(this, varargin)
            psi = this.twistors_.unwrap(varargin{:});
        end
        
        function psi = X(this, varargin)
            psi = this.twistors_.X(varargin{:});
        end

        function psi = Y(this, varargin)
            psi = this.twistors_.Y(varargin{:});
        end

        function psi = Z(this, varargin)
            psi = this.twistors_.Z(varargin{:});
        end

        %% plotting

        function fit_power_law(this, opts)
            %% "In matlab, how best should I examine the power spectrum of a time-series for power law behavior?" 
            %  https://claude.ai/chat/7c0ba283-3bc7-4938-9dec-8acd7bd25e7a
            %  Args:
            %    this mlraut.AnalyticSignal
            %    opts.t double = []
            %    opts.x double = []
            %    opts.title = stackstr(use_spaces=true)

            arguments
                this mlraut.AnalyticSignal
                opts.t double = []
                opts.x double = []
                opts.title = ""
            end
            if isempty(opts.t)
                tf = this.num_frames*this.tr;
                opts.t = 0:this.tr:tf;
            end
            t = opts.t;
            if isempty(opts.x)
                opts.x = this.global_signal;
            end
            x = opts.x;

            % Compute the Fourier transform
            N = length(x);
            X = fft(x);

            % Compute the power spectrum
            P = abs(X).^2 / N;

            % Compute the corresponding frequencies
            fs = 1 / (t(2) - t(1));  % Sampling frequency
            f = (0:N-1)*(fs/N);      % Frequency range

            % Use only the first half of the spectrum (it's symmetric)
            P = P(1:floor(N/2)+1);
            f = f(1:floor(N/2)+1);

            % Plot the power spectrum on a log-log scale
            figure;
            civ = cividis;
            loglog(f, P, LineWidth=2, Color=civ(1,:));
            xlabel('Frequency (Hz)');
            ylabel('Power');
            title(opts.title);
            grid on;

            % Optional: Fit a power law
            % Select a range for fitting (adjust as needed)
            fit_range = f > this.hp_thresh & f < this.lp_thresh;

            % Perform linear regression on log-log data
            p = polyfit(log10(f(fit_range)), log10(P(fit_range)), 1);

            % Add the fit line to the plot
            hold on;
            loglog(f(fit_range), 10.^(polyval(p, log10(f(fit_range)))), 'm--', 'LineWidth', 2);
            legend('BOLD', sprintf('power law exponent = %.2f', p(1)), Location="southeast");
            fontsize(scale=2)

            % Display the slope (which is the power law exponent)
            fprintf('Power law exponent: %.2f\n', p(1));
        end

        function plot3(this, opts)
            arguments
                this mlraut.AnalyticSignal
                opts.t double = []
                opts.z double = []
                opts.num_frames double = []
                opts.title {mustBeTextScalar} = ""
                opts.symbol {mustBeTextScalar} = "\psi"
            end
            if isempty(opts.num_frames)
                opts.num_frames = this.num_frames;  % ceil(300/this.tr);
            end
            if isempty(opts.t)
                tf = (opts.num_frames - 1)*this.tr;
                opts.t = 0:this.tr:tf;
            end
            t = opts.t;
            if isempty(opts.z)

                % select cortical default mode
                ctx = this.average_network_signal(this.task_dtseries(), network_type="cortical");
                select_rsn = contains(mlraut.NetworkData.NETWORKS_YEO_NAMES, "default mode");
                bold_ = ctx(:, select_rsn);

                % aufbau Hilbert transform
                bold_ = ...
                    hilbert( ...
                    this.build_band_passed( ...
                    this.build_centered_and_rescaled( ...
                    this.build_global_signal_regressed(bold_))));

                opts.z = bold_;
            end
            z = opts.z;

            % 3D Line Plot
            figure('Position', [100, 100, 1200, 600]);
            civ = cividis;
            plot3(t, real(z), imag(z), LineWidth=2, Color=civ(1,:));
            xlabel("time / s");
            ylabel(sprintf('Re %s(t)', opts.symbol));
            zlabel(sprintf('Im %s(t)', opts.symbol));
            title(opts.title);
            grid on;
            fontsize(scale=2)
            title(opts.title);

            % Stretch the time axis
            %%current_aspect = pbaspect;
            pbaspect([4 1 1]);  % Stretch time axis (x-axis) by a factor of 3

            % Add a 2D projection onto the complex plane
            figure;
            scatter(real(z), imag(z), [], t, 'filled', 'o', MarkerFaceAlpha=0.618);
            ylabel(sprintf('Re %s(t)', opts.symbol));
            ylabel(sprintf('Im %s(t)', opts.symbol));
            title("");
            axis equal;
            colorbar;
            colormap('cividis');
            c = colorbar;
            c.Label.String = 'time / s';
            fontsize(scale=2)
            title(opts.title);
        end

        function h1 = plot_cmor(this, varargin)
            h1 = this.plotting_.plot_cmor(varargin{:});
        end

        function h1 = plot_cwt(this, varargin)
            h1 = this.plotting_.plot_cwt(varargin{:});
        end

        function plot_emd(this, varargin)
            this.plotting_.plot_emd(varargin{:});
        end

        function h1 = plot_global_physio(this, varargin)
            h1 = this.plotting_.plot_global_physio(varargin{:});
        end

        function plot_regions(this, varargin)
            this.plotting_.plot_regions(varargin{:});
        end

        function [h1,h3] = plot_networks(this, varargin)
            [h1,h3] = this.plotting_.plot_networks(varargin{:});
        end

        function [h1,h3] = plot_networks_dots(this, varargin)
            [h1,h3] = this.plotting_.plot_networks_dots(varargin{:});
        end

        function [h,h1,h2] = plot_radar(this, varargin)
            [h,h1,h2] = this.plotting_.plot_radar(varargin{:});
        end

        function [h,h1] = plot_timeseries_qc(this, varargin)
            [h,h1] = this.plotting_.plot_timeseries_qc(varargin{:});
        end
        
        function h1 = plot_wcoherence(this, varargin)
            h1 = this.plotting_.plot_wcoherence(varargin{:});
        end

        %% helpers for BOLD

        function [physio,pROI] = task_physio(this, opts)
            %  Args:
            %      this mlraut.AnalyticSignal
            %      opts.roi mlfourd.ImagingContext2 = this.roi
            %      opts.flipLR logical = false
            %      opts.source_physio {mustBeText} = this.source_physio
            %      opts.size_dtseries {mustBeNumeric} = size(this.task_dtseries())            
            %  Returns:
            %      physio numeric Nt x Ngo
            %      physio_vec numeric Nt x 1
            %      pROI mlraut.PhysioData : for view_qc(), prop. roi_mask 
            %  Throws:
            %      mlraut:ValueError if this.source_physio not supported

            arguments
                this mlraut.AnalyticSignal
                opts.roi = this.roi
                opts.flipLR logical = false
                opts.source_physio {mustBeText} = this.source_physio
            end

            bold_niigz = this.task_niigz();
            switch convertStringsToChars(opts.source_physio)
                case 'HRV'
                    pROI = [];
                    HRV = mlraut.PhysioHRV(this, bold_niigz);
                    physio_vec_ = HRV.call();
                    physio_vec = ...
                        this.build_rescaled( ...
                        this.build_band_passed( ...
                        this.build_centered(physio_vec_)));
                    physio = physio_vec;
                    assert(all(isfinite(physio), "all"), "likely that opts.reference is faulty")  
                case 'RV'
                    pROI = [];
                    RV = mlraut.PhysioRV(this, bold_niigz);
                    physio_vec_ = RV.call();
                    physio_vec = ...
                        this.build_rescaled( ...
                        this.build_band_passed( ...
                        this.build_centered(physio_vec_)));
                    physio = physio_vec;
                    assert(all(isfinite(physio), "all"), "likely that opts.reference is faulty")

                case 'ROI'
                    pROI = mlraut.PhysioRoi(this, bold_niigz, ...
                        from_imaging_context=opts.roi, flipLR=opts.flipLR);
                    physio = pROI.build_physio_from_ROI();

                case '3rdV'  % propagated
                    pROI = mlraut.ThirdVentricle(this, bold_niigz, flipLR=opts.flipLR);
                    physio = pROI.build_physio_from_ROI();
                case '4thV'  % propagated
                    pROI = mlraut.IFourthVentricle(this, bold_niigz, selected_voxels="all", flipLR=opts.flipLR);
                    physio = pROI.build_physio_from_ROI(); 
                case 'iFV'  % propagated
                    pROI = mlraut.IFourthVentricle(this, bold_niigz, selected_voxels="inferior-half", flipLR=opts.flipLR);
                    physio = pROI.build_physio_from_ROI();
                case 'iFV-brightest'  % propagated
                    pROI = mlraut.IFourthVentricle(this, bold_niigz, selected_voxels="brightest", flipLR=opts.flipLR);
                    physio = pROI.build_physio_from_ROI();
                case 'iFV-quantile'  % propagated
                    pROI = mlraut.IFourthVentricle(this, bold_niigz, selected_voxels="inferior-quantile", flipLR=opts.flipLR);
                    physio = pROI.build_physio_from_ROI();
                case 'sFV'  % propagated
                    pROI = mlraut.IFourthVentricle(this, bold_niigz, selected_voxels="superior-half", flipLR=opts.flipLR);
                    physio = pROI.build_physio_from_ROI();
                case 'latV'% propagated
                    pROI = mlraut.LateralVentricles(this, bold_niigz, flipLR=opts.flipLR);
                    physio = pROI.build_physio_from_ROI();

                case {'CE', 'CE_on_T1w'}  % obtains CE_on_T1w.nii.gz
                    assert(isa(this, "mlraut.AnalyticSignalGBM"))                    
                    pROI = mlraut.PhysioRoi(this, bold_niigz, ...
                        from_imaging_context=this.cohort_data.CE_ic, flipLR=opts.flipLR);
                    physio = pROI.build_physio_from_ROI();
                case {'WT', 'WT_on_T1w'}  % obtains WT_on_T1w.nii.gz
                    assert(isa(this, "mlraut.AnalyticSignalGBM"))
                    pROI = mlraut.PhysioRoi(this, bold_niigz, ...
                        from_imaging_context=this.cohort_data.WT_ic, flipLR=opts.flipLR);
                    physio = pROI.build_physio_from_ROI();
                case {'edema', 'edema_on_T1w'}  % obtains edema_on_T1w.nii.gz
                    assert(isa(this, "mlraut.AnalyticSignalGBM"))
                    pROI = mlraut.PhysioRoi(this, bold_niigz, ...
                        from_imaging_context=this.cohort_data.edema_ic, flipLR=opts.flipLR);
                    physio = pROI.build_physio_from_ROI();
                case {'ctx', 'cortex', 'gray', 'grey'}
                    wmparc = mlsurfer.Wmparc(this.wmparc_fqfn);
                    ic = wmparc.select_gray();
                    pROI = mlraut.PhysioRoi(this, bold_niigz, from_imaging_context=ic, flipLR=opts.flipLR);                    
                    physio = pROI.build_physio_from_ROI();
                case {'cbm', 'cereb', 'cerebellum'}
                    wmparc = mlsurfer.Wmparc(this.wmparc_fqfn);
                    ic = wmparc.select_cerebellum();
                    pROI = mlraut.PhysioRoi(this, bold_niigz, from_imaging_context=ic, flipLR=opts.flipLR); 
                    physio = pROI.build_physio_from_ROI();
                case {'str', 'striatum'}
                    wmparc = mlsurfer.Wmparc(this.wmparc_fqfn);
                    ic = wmparc.select_striatum();
                    pROI = mlraut.PhysioRoi(this, bold_niigz, from_imaging_context=ic, flipLR=opts.flipLR); 
                    physio = pROI.build_physio_from_ROI();
                case {'thal', 'thalamus'}
                    wmparc = mlsurfer.Wmparc(this.wmparc_fqfn);
                    ic = wmparc.select_thalamus();
                    pROI = mlraut.PhysioRoi(this, bold_niigz, from_imaging_context=ic, flipLR=opts.flipLR); 
                    physio = pROI.build_physio_from_ROI();
                case {'no-physio', 'nophys', 'none'}
                    pROI = [];
                    size_dtseries = size(this.task_dtseries());
                    physio = ones(size_dtseries(1), 1);
                    assert(all(isfinite(physio), "all"), "likely that opts.reference is faulty")

                otherwise  % other wmparc regions, propagated
                    wmparc = mlsurfer.Wmparc(this.wmparc_fqfn);
                    nn = wmparc.label_to_num(convertStringsToChars(opts.source_physio));
                    assert(~all(nn == 0), stackstr())
                    pROI = mlraut.PhysioRoi(this, bold_niigz, from_wmparc_indices=nn, flipLR=opts.flipLR);
                    physio = pROI.build_physio_from_ROI();

            end
            % physio_vec = single(physio_vec);
            % physio = single(physio);
            assert(~isempty(physio))
        end

        function cmap = task_physio_supplementary(this, opts)
            %  Args:
            %      this mlraut.AnalyticSignal
            %      opts.flipLR logical = false
            %      opts.source_physio_supplementary {mustBeText} = this.source_physio_supplementary        
            %  Returns:
            %      cmap containers.Map ~ string x (Nt x Ngo)
            %  Throws:
            %      mlraut:ValueError if this.source_physio_supplementary not supported

            arguments
                this mlraut.AnalyticSignal
                opts.flipLR logical = false
                opts.source_physio_supplementary = this.source_physio_supplementary
            end

            if isempty(opts.source_physio_supplementary)
                cmap = [];
                return
            end

            keys = opts.source_physio_supplementary;
            values = cell(1, length(keys));
            for vidx = 1:length(keys)
                values{vidx} = this.task_physio(flipLR=opts.flipLR, source_physio=keys(vidx));
            end
            cmap = containers.Map(keys, values);
        end

        %% misc. helpers

        function t = tags(this, more_tags)
            %% for filenames; see also mat_fqfn()

            arguments
                this mlraut.AnalyticSignal
                more_tags {mustBeTextScalar} = ""
            end

            t = "proc";

            if ~isemptytext(this.source_physio)
                t = t + "-" + this.source_physio;
            end            
            if ~this.v_physio_is_inf
                t = t + "-v" + strrep(num2str(this.v_physio), ".", "p");
            end

            t = t + "-gsr" + double(this.do_global_signal_regression);

            if ~this.force_legacy_butter
                t = t + "-butter" + this.filter_order;
            else
                t = t + "-legacybutter" + this.filter_order;
            end   
            if ~isempty(this.lp_thresh)
                t = t + "-lp" + strrep(num2str(this.lp_thresh), ".", "p");
            else
                t = t + "-lpnone";
            end
            if ~isempty(this.hp_thresh)
                t = t + "-hp" + strrep(num2str(this.hp_thresh), ".", "p");
            else
                t = t + "-hpnone";
            end         
            if isfinite(this.max_frames)
                t = t + "-maxframes" + num2str(this.max_frames);
            end
            if ~isemptytext(this.rescaling)
                t = t + "-scale" + this.rescaling;
            end
            if this.do_save_subset
                t = t + "-subset";
            end
            if ~isemptytext(this.tags_user) 
                t = t + "-" + this.tags_user;
            end
            if ~isemptytext(more_tags) 
                t = t + "-" + more_tags;
            end
        end

        %%

        function this = AnalyticSignal(opts)
            %% ANALYTICSIGNAL 
            %  Args:
            %      opts.anatomy_list {mustBeText} = {'ctx', 'str', 'thal', 'cbm'}
            %      opts.do_7T logical = false
            %      opts.do_resting logical = true
            %      opts.do_task logical = false
            %      opts.do_global_signal_regression logical = true
            %      opts.do_plot_global_physio logical = false
            %      opts.do_plot_networks logical = false
            %      opts.do_plot_radar logical = false
            %      opts.do_plot_wavelets logical = false
            %      opts.do_save logical = true : save fully populated this to mlraut_AnalyticSignal.mat
            %      opts.do_save_bias_to_rsns logical = true
            %      opts.do_save_ciftis logical = false: save ciftis of {abs,angle} of analytic_signal.
            %      opts.do_save_ciftis_mad logical = true
            %      opts.do_save_ciftis_of_diffs logical = false: save ciftis of {abs,angle} of analytic_signal, diff from bold.
            %      opts.do_save_dynamic logical = false; save large dynamic dtseries
            %      opts.do_save_subset logical = false : save only subset of this to decrease storage
            %      opts.filter_order double = 8
            %      opts.force_band logical = false: force bandpass to Nyquist limits of available data
            %      opts.force_legacy_butter logical = false: 
            %      opts.frac_ext_physio double = 0.5 : fraction of external physio signal power
            %      opts.hp_thresh {mustBeScalarOrEmpty} : default := 0.009*0.72, Dworetsky; support ~ 2/this.num_frames ~ 0.0019, compared to Ryan's 0.01.
            %                                             nan =: 2/(this.num_frames - this.num_frames_to_trim).
            %      opts.lp_thresh {mustBeScalarOrEmpty} : default := 0.08*0.72, Dworetsky; support ~ 1/(2*this.tr), compared to Ryan's 0.05-0.1.
            %                                             nan =: 1/2
            %      opts.max_frames double = Inf
            %      opts.out_dir {mustBeFolder} = pwd
            %      opts.rescaling {mustBeTextScalar} = 'iqr' : rescales bold and physio before creating twistor [X,Y,Z,T]
            %      opts.source_physio {mustBeText} = "iFV-brightest" | ["iFV-brightest","iFV-quantile","sFV"]
            %      opts.subjects cell {mustBeText} = {}
            %      opts.tags {mustBeTextScalar} = ""
            %      opts.tasks cell {mustBeText} = {}
            %      opts.v_physio double = 50
            
            arguments
                opts.anatomy_list {mustBeText} = {'ctx', 'str', 'thal', 'cbm'}
                opts.do_7T logical = false
                opts.do_resting logical = true
                opts.do_task logical = false
                opts.do_global_signal_regression logical = true
                opts.do_plot_emd logical = false
                opts.do_plot_global_physio logical = false
                opts.do_plot_networks logical = false
                opts.do_plot_radar logical = false
                opts.do_plot_wavelets logical = false
                opts.do_save logical = false
                opts.do_save_bias_to_rsns logical = false
                opts.do_save_ciftis logical = false
                opts.do_save_ciftis_mad logical = false
                opts.do_save_ciftis_of_diffs logical = false
                opts.do_save_dynamic logical = false
                opts.do_save_subset logical = false
                opts.filter_order double = 8
                opts.force_band logical = false
                opts.force_legacy_butter logical = false
                opts.frac_ext_physio double = 1
                opts.hp_thresh {mustBeScalarOrEmpty} = 0.01
                opts.lp_thresh {mustBeScalarOrEmpty} = 0.1
                opts.max_frames double = Inf
                opts.out_dir {mustBeTextScalar} = ""
                opts.plot_range double = []
                opts.rescaling {mustBeTextScalar} = "iqr"
                opts.source_physio {mustBeText} = "iFV-brightest"
                opts.subjects = {}
                opts.tags {mustBeTextScalar} = ""
                opts.tasks = {}
                opts.v_physio double = 50
            end

            this = this@mlraut.HCP(max_frames=opts.max_frames, subjects=opts.subjects, tasks=opts.tasks)

            % char|string management
            opts.anatomy_list = convertStringsToChars(opts.anatomy_list);
            opts.out_dir = convertCharsToStrings(opts.out_dir);
            opts.rescaling = convertCharsToStrings(opts.rescaling);
            opts.source_physio = convertCharsToStrings(opts.source_physio);
            opts.tags = convertCharsToStrings(opts.tags);

            % path management
            addpath(genpath(fullfile(this.waves_dir, 'Dependencies', '-end')));
            addpath(genpath(fullfile(this.waves_dir, 'supporting_files', '')));

            this.anatomy_list_ = opts.anatomy_list;
            this.do_7T = opts.do_7T;
            this.do_resting = opts.do_resting;
            this.do_task = opts.do_task;
            this.do_global_signal_regression = opts.do_global_signal_regression;
            this.do_plot_emd = opts.do_plot_emd;
            this.do_plot_global_physio = opts.do_plot_global_physio;
            this.do_plot_networks = opts.do_plot_networks;
            this.do_plot_radar = opts.do_plot_radar;
            this.do_plot_wavelets = opts.do_plot_wavelets;
            this.do_save = opts.do_save;
            this.do_save_bias_to_rsns = opts.do_save_bias_to_rsns;
            this.do_save_ciftis = opts.do_save_ciftis;
            this.do_save_ciftis_mad = opts.do_save_ciftis_mad;
            this.do_save_ciftis_of_diffs = opts.do_save_ciftis_of_diffs;
            this.do_save_dynamic = opts.do_save_dynamic;
            this.do_save_subset = opts.do_save_subset;

            this.filter_order = opts.filter_order;
            this.force_band = opts.force_band;
            this.force_legacy_butter = opts.force_legacy_butter;
            this.frac_ext_physio = opts.frac_ext_physio;
            this.hp_thresh_ = opts.hp_thresh;
            this.lp_thresh_ = opts.lp_thresh;
            if ~isempty(this.lp_thresh_) && ~isempty(this.hp_thresh_)
                assert(this.hp_thresh_ < this.lp_thresh_, "hp_thresh < lp_thresh is required")
            end
            this.max_frames = opts.max_frames;
            this.cohort_data_.out_dir = opts.out_dir;
            this.rescaling_ = opts.rescaling;
            this.source_physio = opts.source_physio(1);
            if ~isscalar(opts.source_physio)
                this.source_physio_supplementary = opts.source_physio(2:end);
            end
            this.tags_user_ = opts.tags;
            this.v_physio = opts.v_physio;
        end
    end

    %% PROTECTED

    properties (Access = protected)
        anatomy_list_
        digital_filter_
        hp_thresh_
        lp_thresh_
        plotting_
        rescaling_
        scale_to_hcp_
        tags_user_

        bold_signal_  % double
        global_signal_  % double
        physio_angle_  % double
        physio_signal_  % double
        physio_supplementary_  % containers.Map ~ string x double
        roi_  % [] | mlfourd.ImagingContext2
    end

    methods (Access = protected)
        function that = copyElement(this)
            that = copyElement@matlab.mixin.Copyable(this);
            if ~isempty(this.plotting_)
                that.plotting_ = copy(this.plotting_); end
            if ~isempty(this.roi_)
                that.roi_ = copy(this.roi_); end
        end
    end
    
    %  Created with mlsystem.Newcl, inspired by Frank Gonzalez-Morphy's newfcn.
end
